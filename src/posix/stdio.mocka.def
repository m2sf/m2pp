(*!m2pim+mocka*) (* Copyright (c) 2017 Modula-2 Software Foundation *)

DEFINITION MODULE stdio; (* MOCKA version *)

(* Modula-2 interface to POSIX stdio *)
  
IMPORT stdio0;
FROM SYSTEM IMPORT BYTE;


CONST
  EPERM        (* Operation not permitted *) = stdio0.EPERM;
  ENOENT       (* No such file or directory *) = stdio0.ENOENT;
  EIO          (* Input/output error *) = stdio0.EIO;
  ENXIO        (* Device not configured *) = stdio0.ENXIO;
  E2BIG        (* Argument list too long *) = stdio0.E2BIG;
  EBADF        (* Bad file descriptor *) = stdio0.EBADF;
  ENOMEM       (* Cannot allocate memory *) = stdio0.ENOMEM;
  EACCES       (* Permission denied *) = stdio0.EACCES;
  EFAULT       (* Bad address *) = stdio0.EFAULT;
  ENOTBLK      (* Block device required *) = stdio0.ENOTBLK;
  EBUSY        (* Device or resource busy *) = stdio0.EBUSY;
  EEXIST       (* File exists *) = stdio0.EEXIST;
  EXDEV        (* Cross-device link *) = stdio0.EXDEV;
  ENODEV       (* Operation not supported by device *) = stdio0.ENODEV;
  ENOTDIR      (* Not a directory *) = stdio0.ENOTDIR;
  EISDIR       (* Is a directory *) = stdio0.EISDIR;
  EINVAL       (* Invalid argument *) = stdio0.EINVAL;
  ENFILE       (* Too many open files in system *) = stdio0.ENFILE;
  EMFILE       (* Too many open files *) = stdio0.EMFILE;
  ENOTTY       (* Inappropriate ioctl for device *) = stdio0.ENOTTY;
  ETXTBSY      (* Text file busy *) = stdio0.ETXTBSY;
  EFBIG        (* File too large *) = stdio0.EFBIG;
  ENOSPC       (* No space left on device *) = stdio0.ENOSPC;
  ESPIPE       (* Illegal seek *) = stdio0.ESPIPE;
  EROFS        (* Read-only file system *) = stdio0.EROFS;
  EMLINK       (* Too many links *) = stdio0.EMLINK;
  EPIPE        (* Broken pipe *) = stdio0.EPIPE;
  EAGAIN       (* Resource temporarily unavailable *) = stdio0.EAGAIN;
  EWOULDBLOCK  (* Operation would block *) = stdio0.EWOULDBLOCK;
  ELOOP        (* Too many levels of symbolic links *) = stdio0.ELOOP;
  ENAMETOOLONG (* File name too long *) = stdio0.ENAMETOOLONG;
  ENOTEMPTY    (* Directory not empty *) = stdio0.ENOTEMPTY;
  EFTYPE       (* Inappropriate file type or format *) = stdio0.EFTYPE;
  EPWROFF      (* Device power is off *) = stdio0.EPWROFF;
  EDEVERR      (* Device error *) = stdio0.EDEVERR;
  ENODATA      (* No message available on STREAM *) = stdio0.ENODATA;
  ENOSR        (* No STREAM resources *) = stdio0.ENOSR;
  ENOSTR       (* Not a STREAM *) = stdio0.ENOSTR;
  ETIME        (* STREAM ioctl timeout *) = stdio0.ETIME;


(* type FILE *)

TYPE FILE = stdio0.FILE;


(* type size_t *)

TYPE SizeT = stdio0.SizeT;


(* type int *)

TYPE INT = stdio0.INT;


(* fopen() *)

PROCEDURE fopen ( filename, mode : ARRAY OF CHAR ) : FILE;


(* fflush() *)

CONST fflush = stdio0.fflush;


(* fclose() *)

CONST fclose = stdio0.fclose;


(* feof() *)

CONST feof = stdio0.feof;


(* fgetc() *)

CONST fgetc = stdio0.fgetc;


(* fputc() *)

CONST fputc = stdio0.fputc;


(* fread() *)

PROCEDURE fread
  ( VAR data : ARRAY OF BYTE; size, items  : SizeT; stream : FILE ) : SizeT;


(* fwrite() *)

PROCEDURE fwrite
  ( data : ARRAY OF BYTE; size, items  : SizeT; stream : FILE ) : SizeT;


(* rename() *)

PROCEDURE rename ( old, new : ARRAY OF CHAR ) : INT;


(* remove() *)

PROCEDURE remove ( path : ARRAY OF CHAR ) : INT;


(* ferror() *)

CONST ferror = stdio0.ferror;


(* clearerr() *)

CONST clearerr = stdio.clearerr;


END stdio.